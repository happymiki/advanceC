#include <stdio.h>#include <string.h>#include <stdlib.h>// 构建一个链表节点struct node{	int data;				// 有效数据	struct node *pNext;		// 指向下一个节点的指针};// 创建一个链表的节点// 返回值：指针，指向本函数新创建的节点的首地址struct node * creat_node(int data){	// 创建一个链表的节点	struct node *p = (struct node *)malloc(sizeof(struct node));		if (NULL == p)	{		printf("malloc error.\n");		return NULL;	}		// 清理申请到的堆内存	bzero(p,sizeof(struct node));		// 填充节点	p -> data = data;	p -> pNext = NULL;		// 将来要指向下一个节点的首地址		return p;}// 思路：头指针向后走，知道走到原来最后一个节点，原来最后一个节点里面的pNext是NULL,现在只需要改成new，添加之后新节点变成最后一个。// 计算添加了新的节点后总共有多少个节点，容纳后写入头节点中void insert_tail(struct node *pH,struct node *new){	// 分两步插入	// 先找到链表中最后一个节点	struct node *p = pH;	int cnt = 0;		while (NULL != p->pNext)	{		p = p->pNext;		// 未找到，往后走一个节点		cnt ++;	}			// 将新节点插入到最后一个节点尾部	p->pNext = new;	pH->data = cnt+1;}// 思路：void insert_head(struct node *pH,struct node *new){	// 新节点的next指向原来的第一个节点	new->pNext = pH->pNext;		// 头节点的next指向新节点的地址	pH->pNext = new;		// 头节点的计数+1	pH->data += 1;}// 遍历单链表，pH为指向单链表的头指针，遍历的数据打印出来void traversal_1(struct node *pH){	struct node *p = pH->pNext;	printf("start!.\n");	//pH->data;		// 头节点的数据，不是常规数据，不要算进去		while (NULL != p->pNext)		// 是不是最后一个节点	{		printf("node data:%d.\n",p->data);		p = p->pNext;		// 循环的增量	}	printf("node data:%d.\n",p->data);	printf("end!.\n");}void traversal_2(struct node *pH){	struct node *p = pH;	printf("start!.\n");	//pH->data;		// 头节点的数据，不是常规数据，不要算进去		while (NULL != p->pNext)		// 是不是最后一个节点	{		p = p->pNext;		// 循环的增量		printf("node data:%d.\n",p->data);	}	printf("end!.\n");}// 从链表的pH中删除节点，数据为data// 找到并删除了节点返回0，未找到节点返回-1。int delete_node(struct node *pH,int data){	// 找到这个待删除的节点，通过遍历链表查找	struct node *p = pH;	// 用来指向当前节点	struct node *pPrev;		// 用来指向当前节点的前一个节点		while (NULL != p->pNext)		// 是不是最后一个节点	{		pPrev = p;			// p走向下一个节点之前，将其保存		p = p->pNext;		// 循环的增量		// 判断这个节点是不是要找的节点		if (p->data == data)		{			// 找到了这个节点，处理这个节点			// 分为两种情况：找到是普通节点，另一种是找到了尾节点			// 删除节点的困难点，通过遍历依次访问节点，找到这个节点			// 后p指向了这个节点，但是要删除这个节点的关键操作前一个节点			// 但是这时候已经没有指针指向前一个节点，所以没法操作。			// 解决方案：增加一个指针，指向前一个节点			if (NULL == p->pNext)			{				// 尾节点				pPrev->pNext = NULL;	// 原来尾节点的前一个节点变成尾节点				free(p);				// 释放原来尾节点的内存				}			else			{				pPrev->pNext = p->pNext;	// 要删除的节点的前一个节点指向后一个节点				free(p);				// 释放原来节点的内存				}			// 处理完成之后退出函数			return 0;		}	}		// 到这里还没找到，说明链表中没有这个节点	printf("not this node !");		return -1;	}// 将pH指向的链表逆序void reverse_linked_list(struct node *pH){	struct node *p = pH->pNext;	// pH指向头节点，p指向第一个有效节点	struct node *pBack;		// 保存当前节点的后一个节点的地址			if ((NULL == p) || (NULL == p->pNext))	// 链表没有有效节点，或者只有一个有效节点	{		return;	}		// 当链表有两个以上节点是才进行逆序操作	while (NULL != p->pNext)		// 是不是最后一个节点	{		// 原链表中第一个有效节点逆序后将是新链表的尾节点，尾节点的pNext指向NULL		pBack = p -> pNext;			// 保存p节点的后一个节点的地址		if (p == pH->pNext)		{			// 原链表的第一个有效节点			p->pNext = NULL;		}		else		{			// 原链表的非第一个有效节点			p->pNext = pH->pNext;		}		pH->pNext = p;				// p = p -> pNext;		//  这样已经不行了，因为p->pNext已经被改过了		p = pBack;		// 走到了下一个节点	}	// 循环结束后，最后一个节点仍然缺失	insert_head(pH,p);}int main(void){	//struct node *pHeader = NULL;	struct node *pHeader = creat_node(0);	insert_tail(pHeader,creat_node(11));	insert_tail(pHeader,creat_node(12));	insert_tail(pHeader,creat_node(13));	insert_tail(pHeader,creat_node(14));		traversal_2(pHeader);		reverse_linked_list(pHeader);		printf("----------逆序后---------.\r\n");		traversal_2(pHeader);		return 0;}